关于继承

组合继承

组合继承，一方面通过子类实例调用了父类的构造函数，从而达到了继承父类属性的效果，另一方面为了继承父类的原型方法，又将父类的实例赋值给子类原型，从打印结果来看，原型链多出了一个`name`属性，写法不够优雅

```javascript
function Person(name) {
    this.name = name
}
Person.prototype.sayName = function () {
    alert(this.name)
}
function Man (name) {
    Person.apply(this, arguments)
}
Man.prototype = new Person()
var M1 = new Man('Envas')
console.log(M1)
```

打印结果：

![组合继承](https://s2.ax1x.com/2019/05/27/VVqA4P.png)



寄生组合继承

寄生组合继承，实际上就是将父类的属性和原型分别继承给子类，通过`Object.create`浅拷贝父类的原型赋值给子类原型，弥补了之前组合继承中存在的问题

```javascript
function Person(name) {
    this.name = name
}
Person.prototype.sayName = function () {
    alert(this.name)
}
function Man (name) {
    Person.apply(this, arguments)
}
Man.prototype = Object.create(Person.prototype)
var M1 = new Man('Envas')
console.log(M1)
```

打印结果：

![寄生组合继承](https://s2.ax1x.com/2019/05/27/VVXRrF.png)





总结：可以看到，ES5的继承就是先通过（Person.apply(this, arguments)）为子类实例对象绑定属性，接着将父类原型赋值给子类原型，间接使子类实例同时拥有了父类的方法和属性



> ES5的原型及继承写法一直都是特别繁琐，ES6为我们提供了更优雅的写法

```javascript
class Person {
    constructor (name) {
        this.name = name
    }
    sayName () {
        alert(this.name)
    }
    static test() {
        console.log('static method')
    }
}

class Man extends Person {
    constructor (name) {
        console.log(super(name))
        super(name)
    }
}

let M1 = new Man('envas')
console.log(M1)
```

打印结果：

![es6](https://s2.ax1x.com/2019/05/28/Veyt2t.png)

ES6的继承，已经帮我们将子类实例的原型的`constructor`指向了子类构造函数`Man`，实际上在ES5需要手动设置才可以做到这一点

```javascript

```

关于`super`,在[ECMAScript 6 入门](http://es6.ruanyifeng.com/)指出：

"子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this`对象"

实际上`super`方法相当于

```javascript
A.prototype.constructor.call(this, props)
```







